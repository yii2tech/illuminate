<?php
/**
 * @link https://github.com/yii2tech
 * @copyright Copyright (c) 2019 Yii2tech
 * @license [New BSD License](http://www.opensource.org/licenses/bsd-license.php)
 */

namespace Yii2tech\Illuminate\Yii\Web;

use Illuminate\Http\Response as IlluminateResponse;
use Symfony\Component\HttpFoundation\Cookie;
use Yii;
use yii\base\InvalidConfigException;
use yii\web\HeadersAlreadySentException;

/**
 * Response fills up Laravel HTTP response instead of sending itself back to the user agent.
 *
 * This class allows Laravel middleware to perform post processing for the responses generated by Yii.
 *
 * Application configuration example:
 *
 * ```php
 * return [
 *     'components' => [
 *         'response' => Yii2tech\Illuminate\Yii\Web\Response::class,
 *         // ...
 *     ],
 *     // ...
 * ];
 * ```
 *
 * Usage of this component also allows returning of the response generated by Laravel from Yii controller. For example:
 *
 * ```php
 * class FooController extends \yii\web\Controller
 * {
 *     public function actionFoo()
 *     {
 *         // ...
 *         return Yii::$app->response->setIlluminateResponse(redirect('foo/create')->withInput());
 *     }
 * }
 * ```
 *
 * @see \Illuminate\Http\Response
 * @see \Yii2tech\Illuminate\Http\YiiApplicationMiddleware
 *
 * @property \Illuminate\Http\Response $illuminateResponse related Laravel response.
 *
 * @author Paul Klimov <klimov.paul@gmail.com>
 * @since 1.0
 */
class Response extends \yii\web\Response
{
    /**
     * @var \Illuminate\Http\Response|null related Laravel response.
     */
    private $_illuminateResponse;

    /**
     * @param  bool  $create whether to create a response, if it is empty.
     * @return \Illuminate\Http\Response|null
     */
    public function getIlluminateResponse(bool $create = false): ?IlluminateResponse
    {
        if ($create && $this->_illuminateResponse === null) {
            $this->_illuminateResponse = $this->createIlluminateResponse();
        }

        return $this->_illuminateResponse;
    }

    /**
     * @param  \Illuminate\Http\Response|null  $illuminateResponse
     * @return static reference.
     */
    public function setIlluminateResponse(?IlluminateResponse $illuminateResponse): self
    {
        $this->_illuminateResponse = $illuminateResponse;

        return $this;
    }

    /**
     * Creates default {@see $illuminateResponse} instance.
     *
     * @return \Illuminate\Http\Response Laravel response instance.
     */
    protected function createIlluminateResponse(): IlluminateResponse
    {
        return \Illuminate\Container\Container::getInstance()->make(IlluminateResponse::class);
    }

    /**
     * {@inheritdoc}
     */
    public function clear(): void
    {
        parent::clear();

        $this->setIlluminateResponse(null);
    }

    /**
     * {@inheritdoc}
     */
    public function send(): void
    {
        if ($this->getIlluminateResponse() !== null) {
            $this->isSent = true;

            return;
        }

        parent::send();
    }

    /**
     * {@inheritdoc}
     */
    protected function prepare(): void
    {
        if ($this->stream === null) {
            // avoid usage of response bridge for file sending, since it may cause PHP memory error.
            $response = $this->getIlluminateResponse();
            if ($response === null) {
                $this->setIlluminateResponse($this->createIlluminateResponse());
            }
        }

        parent::prepare();
    }

    /**
     * {@inheritdoc}
     */
    protected function sendHeaders(): void
    {
        $response = $this->getIlluminateResponse();
        if ($response === null) {
            parent::sendHeaders();

            return;
        }

        if (headers_sent($file, $line)) {
            throw new HeadersAlreadySentException($file, $line);
        }

        $response->setProtocolVersion($this->version);
        $response->setStatusCode($this->getStatusCode(), $this->statusText);

        foreach ($this->getHeaders() as $name => $values) {
            $response->headers->set($name, $values);
        }

        $this->sendCookies();
    }

    /**
     * {@inheritdoc}
     */
    protected function sendCookies(): void
    {
        $response = $this->getIlluminateResponse();
        if ($response === null) {
            parent::sendCookies();

            return;
        }

        $request = Yii::$app->getRequest();
        if ($request->enableCookieValidation) {
            if ($request->cookieValidationKey == '') {
                throw new InvalidConfigException(get_class($request) . '::$cookieValidationKey must be configured with a secret key.');
            }
            $validationKey = $request->cookieValidationKey;
        }

        foreach ($this->getCookies() as $cookie) {
            $value = $cookie->value;
            if ($cookie->expire != 1 && isset($validationKey)) {
                $value = Yii::$app->getSecurity()->hashData(serialize([$cookie->name, $value]), $validationKey);
            }

            $response->headers->setCookie(new Cookie($cookie->name, $value, $cookie->expire, $cookie->path, $cookie->domain, $cookie->secure, $cookie->httpOnly));
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function sendContent(): void
    {
        $response = $this->getIlluminateResponse();
        if ($response === null) {
            parent::sendContent();

            return;
        }

        if ($this->stream === null) {
            $response->setContent($this->content);

            return;
        }

        ob_start();
        ob_implicit_flush(false);

        try {
            parent::sendContent();

            $response->setContent(ob_get_clean());
        } catch (\Throwable $e) {
            if (!@ob_end_clean()) {
                ob_clean();
            }
            throw $e;
        }
    }
}
